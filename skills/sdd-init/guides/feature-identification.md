# 特性识别与 Skill 拆分指南

## 概述

在使用 Skill-Driven Development（SDD）方法时，最关键的第一步就是：**识别项目中有哪些特性（Feature），以及它们应该被拆分为几个 Skill**。

拆得太细，维护成本高、上下文碎片化；拆得太粗，单个 Skill 膨胀、AI 难以聚焦。本指南提供一套实用的判断标准和操作策略，帮助你做出合理的拆分决策。

---

## 1. 拆分判断清单（6 个信号）

当你面对一个项目，不确定某个模块是否应该独立为一个 Skill 时，逐条对照下表：

| # | 信号 | 建议 | 说明 |
|---|------|------|------|
| 1 | 有独立的文件目录 | 拆分为独立 Skill | 如果某个模块在代码仓库中有自己的目录（如 `src/payment/`、`modules/auth/`），说明它在架构上已经被当作独立单元，适合作为独立 Skill。 |
| 2 | 有独立的 API / 接口 | 拆分为独立 Skill | 如果某个模块对外暴露了独立的 API 端点（如 `/api/orders/*`）或定义了独立的接口契约，它的修改和调试通常是自包含的。 |
| 3 | 有独立的配置参数 | 拆分为独立 Skill | 如果某个模块有自己的配置文件或配置段（如支付网关密钥、邮件服务配置），说明它有独立的运行时依赖，值得单独管理。 |
| 4 | 需要专属的调试知识 | 拆分为独立 Skill | 如果排查某个模块的问题需要特定的背景知识（如"支付回调的签名验证流程"、"消息队列的重试机制"），把这些知识封装到独立 Skill 中能显著提升 AI 的诊断效率。 |
| 5 | 仅是某系统的子模块 | 合并到父系统 Skill | 如果某个部分不能脱离父模块独立理解（如"订单状态机"只是订单系统的一部分），就不要强行拆出来，保持在父 Skill 中即可。 |
| 6 | 代码量 < 500 行 | 考虑合并到框架 Skill | 如果某个模块的代码量很小（比如一个工具函数库、一个简单的中间件），单独建 Skill 的开销大于收益，建议合并到更大的框架级 Skill。 |

### 怎么用这张表？

数一下某个模块命中了几条"拆分"信号：

- **命中 3 条及以上** --> 强烈建议拆分为独立 Skill
- **命中 1-2 条** --> 视情况而定，可以先合并，等痛点出现再拆
- **命中 0 条** --> 合并到父级或框架 Skill

---

## 2. 粒度原则

> **一个 Skill 对应一个开发者可能说"我要修/改/优化 XXX"的那个 XXX。**

这是最直觉的判断方法。举几个例子：

- "我要改一下**用户登录**的逻辑" --> "用户认证" 是一个 Skill
- "我要优化**订单查询**的性能" --> "订单系统" 是一个 Skill
- "我要修**支付回调**的 bug" --> "支付系统" 是一个 Skill
- "我要改一下那个**日期格式化**的工具函数" --> 太细了，合并到 "公共工具" 或 "框架基础" Skill

如果你发现自己很难用一个短语命名一个 Skill（比如不得不说"用户登录和权限管理和第三方OAuth集成"），那说明这个 Skill 可能需要拆分。

反过来，如果一个 Skill 的名字太过具体（比如"密码加密工具函数"），那它可能粒度太细了。

---

## 3. 渐进式拆分策略

**核心理念：先粗后细，按需拆分。**

不要一开始就试图设计出完美的 Skill 拆分方案。推荐的演进路径：

### 第一阶段：1 个框架级 Skill

刚开始接入 SDD 时，为整个项目创建一个大的框架级 Skill。这个 Skill 包含：

- 项目整体架构说明
- 技术栈和约定
- 主要模块的概述
- 通用的开发规范

**这个阶段的目的是：先跑起来，积累使用经验。**

### 第二阶段：拆分出痛点模块

使用一段时间后，你会发现某些模块被反复提及、反复修改。比如：

- 每次改支付逻辑都要重新解释一遍支付流程
- 每次调数据库查询都要提醒 AI 注意索引设计

这些"高频修改 + 需要专属知识"的模块，就是优先拆分的对象。

### 第三阶段：稳定后精细化

当项目趋于稳定，各个核心模块都有了独立的 Skill，可以进一步：

- 为关键 Skill 补充更多上下文（如常见故障清单、性能基线）
- 拆分出通用层（如"数据库访问层"、"中间件层"）

### 何时停止拆分？

当你发现新拆出的 Skill 带来的收益（AI 理解更准确、回答更聚焦）小于维护成本（需要同步更新多个 Skill 文件）时，就停止。

---

## 4. 不同项目规模的推荐 Skill 数量

| 项目规模 | 代码行数 | 推荐 Skill 数量 | 典型组成 |
|----------|----------|-----------------|----------|
| 小型项目 | < 10K 行 | 1 - 3 个 | 1 个框架 Skill + 1-2 个核心模块 Skill |
| 中型项目 | 10K - 100K 行 | 5 - 10 个 | 1 个框架 Skill + 若干业务模块 Skill + 1-2 个基础设施 Skill |
| 大型项目 | > 100K 行 | 10 - 20+ 个 | 按子系统/微服务边界划分，每个子系统 2-5 个 Skill |

**注意：这只是经验参考值，实际数量取决于项目的模块化程度和团队的使用频率。** 一个 10 万行但高度模块化的项目可能只需要 5 个 Skill；一个 2 万行但逻辑耦合严重的项目可能需要 8 个。

---

## 5. 完整示例：电商后端项目的 Skill 拆分

### 项目背景

假设有一个电商后端项目，技术栈为 Node.js + Express + MySQL + Redis，包含以下模块：

```
ecommerce-backend/
├── src/
│   ├── user/           # 用户系统（注册、登录、个人信息、地址管理）
│   ├── product/        # 商品系统（商品 CRUD、分类、搜索、库存）
│   ├── order/          # 订单系统（下单、订单状态、退款、物流跟踪）
│   ├── payment/        # 支付系统（微信支付、支付宝、回调处理）
│   ├── notification/   # 通知系统（短信、邮件、站内信）
│   ├── middleware/      # 中间件（鉴权、日志、限流）
│   ├── utils/          # 工具函数（日期、加密、校验）
│   └── config/         # 配置（数据库、Redis、第三方服务）
├── database/
│   └── migrations/     # 数据库迁移脚本
├── tests/
└── package.json
```

### 逐模块分析

#### 用户系统（`src/user/`）

| 信号 | 是否命中 |
|------|---------|
| 有独立的文件目录 | 命中 -- `src/user/` |
| 有独立的 API | 命中 -- `/api/users/*`, `/api/auth/*` |
| 有独立的配置参数 | 命中 -- JWT 密钥、OAuth 配置 |
| 需要专属调试知识 | 命中 -- Token 刷新机制、权限模型 |
| 仅是子模块 | 未命中 |
| 代码量 < 500 行 | 未命中（约 2000 行） |

**结论：命中 4 条拆分信号，拆分为独立 Skill "用户系统"。**

#### 商品系统（`src/product/`）

| 信号 | 是否命中 |
|------|---------|
| 有独立的文件目录 | 命中 |
| 有独立的 API | 命中 -- `/api/products/*`, `/api/categories/*` |
| 有独立的配置参数 | 部分命中 -- 搜索引擎配置（如 Elasticsearch） |
| 需要专属调试知识 | 命中 -- 搜索索引构建、库存扣减的并发控制 |
| 仅是子模块 | 未命中 |
| 代码量 < 500 行 | 未命中（约 3000 行） |

**结论：命中 4 条拆分信号，拆分为独立 Skill "商品系统"。**

#### 订单系统（`src/order/`）

| 信号 | 是否命中 |
|------|---------|
| 有独立的文件目录 | 命中 |
| 有独立的 API | 命中 -- `/api/orders/*` |
| 有独立的配置参数 | 部分命中 -- 物流 API 配置 |
| 需要专属调试知识 | 命中 -- 订单状态机、退款流程、库存回滚 |
| 仅是子模块 | 未命中 |
| 代码量 < 500 行 | 未命中（约 4000 行） |

**结论：命中 4 条拆分信号，拆分为独立 Skill "订单系统"。**

#### 支付系统（`src/payment/`）

| 信号 | 是否命中 |
|------|---------|
| 有独立的文件目录 | 命中 |
| 有独立的 API | 命中 -- `/api/payment/*`、回调端点 |
| 有独立的配置参数 | 命中 -- 微信支付/支付宝商户号、密钥、证书路径 |
| 需要专属调试知识 | 强烈命中 -- 签名验证、异步回调处理、对账逻辑 |
| 仅是子模块 | 未命中 |
| 代码量 < 500 行 | 未命中（约 1500 行） |

**结论：命中 4 条拆分信号（且调试复杂度高），拆分为独立 Skill "支付系统"。**

#### 通知系统（`src/notification/`）

| 信号 | 是否命中 |
|------|---------|
| 有独立的文件目录 | 命中 |
| 有独立的 API | 部分命中 -- 主要被其他模块内部调用 |
| 有独立的配置参数 | 命中 -- 短信服务商配置、邮件 SMTP 配置 |
| 需要专属调试知识 | 部分命中 |
| 仅是子模块 | 未命中 |
| 代码量 < 500 行 | 边缘（约 800 行） |

**结论：命中 2-3 条，体量偏小。初期可合并到框架 Skill，如果后续短信/邮件发送频繁出问题再拆出来。**

#### 中间件 + 工具函数（`src/middleware/` + `src/utils/`）

| 信号 | 是否命中 |
|------|---------|
| 有独立的文件目录 | 命中（但都是辅助性目录） |
| 有独立的 API | 未命中 |
| 有独立的配置参数 | 部分命中 |
| 需要专属调试知识 | 未命中 |
| 仅是子模块 | 命中 -- 服务于其他所有模块 |
| 代码量 < 500 行 | 命中（各约 300-500 行） |

**结论：命中 2 条合并信号，合并到框架 Skill。**

### 最终拆分方案

```
电商后端项目 Skill 拆分结果（共 5 个 Skill）
├── Skill 1: 框架基础
│   ├── 覆盖范围：项目架构、技术栈、中间件、工具函数、通知系统、配置管理
│   ├── 关键文件：src/middleware/、src/utils/、src/notification/、src/config/
│   └── 定位：整体上下文 + 通用知识
│
├── Skill 2: 用户系统
│   ├── 覆盖范围：注册登录、JWT 认证、OAuth、权限管理、用户信息、地址管理
│   ├── 关键文件：src/user/
│   └── 定位：身份与权限相关的所有逻辑
│
├── Skill 3: 商品系统
│   ├── 覆盖范围：商品 CRUD、分类管理、搜索功能、库存管理
│   ├── 关键文件：src/product/
│   └── 定位：商品领域的所有逻辑
│
├── Skill 4: 订单系统
│   ├── 覆盖范围：下单流程、订单状态机、退款、物流跟踪
│   ├── 关键文件：src/order/
│   └── 定位：交易流程的核心逻辑
│
└── Skill 5: 支付系统
    ├── 覆盖范围：支付发起、回调处理、签名验证、对账
    ├── 关键文件：src/payment/
    └── 定位：资金相关的敏感逻辑
```

### 演进路径

这个方案不是一步到位的。实际的演进过程是：

1. **第 1 周**：只建 1 个"框架基础" Skill，涵盖整个项目
2. **第 2 周**：发现支付回调的 bug 排查每次都要重复解释签名流程 --> 拆出"支付系统" Skill
3. **第 3 周**：订单状态流转逻辑复杂，AI 经常搞混 --> 拆出"订单系统" Skill
4. **第 4 周**：用户权限改动频繁 --> 拆出"用户系统" Skill
5. **后续**：商品搜索优化需要专门的 Elasticsearch 知识 --> 拆出"商品系统" Skill
6. **再后续**：通知系统接入了新的推送渠道，逻辑变复杂 --> 从框架 Skill 中拆出"通知系统" Skill

---

## 总结

| 要点 | 内容 |
|------|------|
| 核心判断标准 | 6 个信号的清单，命中 3 条以上就拆分 |
| 粒度直觉 | 开发者会说"我要改 XXX"的那个 XXX |
| 拆分策略 | 先粗后细，从 1 个 Skill 开始，遇到痛点再拆 |
| 数量参考 | 小项目 1-3 个，中项目 5-10 个，大项目 10-20+ 个 |
| 停止条件 | 拆分的收益 < 维护的成本时停止 |
